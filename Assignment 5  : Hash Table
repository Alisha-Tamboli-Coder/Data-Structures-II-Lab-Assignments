Set A 
a) Write a program to implement various types of hash functions which are used to place the data in a hash table 
a. Division Method 
b. Mid Square Method 
c. Digit Folding Method 
Accept n values from the user and display appropriate message in case of collision for each of the above functions. 

#include <stdio.h>
#define SIZE 10

int table_div[SIZE], table_mid[SIZE], table_fold[SIZE];

/* Division Method */
int divisionHash(int key) {
    return key % SIZE;
}

/* Mid Square Method */
int midSquareHash(int key) {
    int square = key * key;
    return (square / 10) % SIZE;
}

/* Digit Folding Method */
int digitFoldingHash(int key) {
    int sum = 0;
    while (key > 0) {
        sum += key % 10;
        key /= 10;
    }
    return sum % SIZE;
}

void init() {
    for (int i = 0; i < SIZE; i++) {
        table_div[i] = table_mid[i] = table_fold[i] = -1;
    }
}

void insert(int key) {
    int index;

    index = divisionHash(key);
    if (table_div[index] != -1)
        printf("Collision in Division Method at index %d\n", index);
    else
        table_div[index] = key;

    index = midSquareHash(key);
    if (table_mid[index] != -1)
        printf("Collision in Mid Square Method at index %d\n", index);
    else
        table_mid[index] = key;

    index = digitFoldingHash(key);
    if (table_fold[index] != -1)
        printf("Collision in Digit Folding Method at index %d\n", index);
    else
        table_fold[index] = key;
}

int main() {
    int n, key;
    init();

    printf("Enter number of values: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("Enter value: ");
        scanf("%d", &key);
        insert(key);
    }

    return 0;
}

b) Write a C program to implement a hash table using separate chaining with linked lists with following operation. a. Insert a key b. Search a key c. Delete a key d. Display the hash table.
#include <stdio.h>
#include <stdlib.h>

#define SIZE 10

struct node {
    int data;
    struct node* next;
};

struct node* table[SIZE];

int hash(int key) {
    return key % SIZE;
}

void insert(int key) {
    int index = hash(key);
    struct node* newNode = (struct node*)malloc(sizeof(struct node));
    newNode->data = key;
    newNode->next = table[index];
    table[index] = newNode;
}

void search(int key) {
    int index = hash(key);
    struct node* temp = table[index];
    while (temp) {
        if (temp->data == key) {
            printf("Search Found\n");
            return;
        }
        temp = temp->next;
    }
    printf("Search Not Found\n");
}

void delete(int key) {
    int index = hash(key);
    struct node *temp = table[index], *prev = NULL;

    while (temp) {
        if (temp->data == key) {
            if (prev)
                prev->next = temp->next;
            else
                table[index] = temp->next;
            free(temp);
            printf("Key Deleted\n");
            return;
        }
        prev = temp;
        temp = temp->next;
    }
    printf("Key Not Found\n");
}

void display() {
    for (int i = 0; i < SIZE; i++) {
        printf("%d: ", i);
        struct node* temp = table[i];
        while (temp) {
            printf("%d -> ", temp->data);
            temp = temp->next;
        }
        printf("NULL\n");
    }
}

int main() {
    int choice, key;
    for (int i = 0; i < SIZE; i++)
        table[i] = NULL;

    while (1) {
        printf("\n1.Insert 2.Search 3.Delete 4.Display 5.Exit\n");
        scanf("%d", &choice);

        switch (choice) {
        case 1:
            printf("Enter key: ");
            scanf("%d", &key);
            insert(key);
            break;
        case 2:
            printf("Enter key: ");
            scanf("%d", &key);
            search(key);
            break;
        case 3:
            printf("Enter key: ");
            scanf("%d", &key);
            delete(key);
            break;
        case 4:
            display();
            break;
        case 5:
            exit(0);
        }
    }
}


Set B 
a)	Write a C program to implement a hash table using open addressing with linear probing.perform the following operations.( Assume all keys are positive integers) a. Insert b. Search c. Delete d. Display 
#include <stdio.h>
#define SIZE 10

int table[SIZE];

int hash(int key) {
    return key % SIZE;
}

void init() {
    for (int i = 0; i < SIZE; i++)
        table[i] = -1;
}

void insert(int key) {
    int index = hash(key);
    while (table[index] != -1) {
        index = (index + 1) % SIZE;
    }
    table[index] = key;
}

void search(int key) {
    int index = hash(key);
    int start = index;

    while (table[index] != -1) {
        if (table[index] == key) {
            printf("Search Found\n");
            return;
        }
        index = (index + 1) % SIZE;
        if (index == start)
            break;
    }
    printf("Search Not Found\n");
}

void delete(int key) {
    int index = hash(key);
    int start = index;

    while (table[index] != -1) {
        if (table[index] == key) {
            table[index] = -1;
            printf("Key Deleted\n");
            return;
        }
        index = (index + 1) % SIZE;
        if (index == start)
            break;
    }
    printf("Key Not Found\n");
}

void display() {
    for (int i = 0; i < SIZE; i++)
        printf("%d : %d\n", i, table[i]);
}

int main() {
    int choice, key;
    init();

    while (1) {
        printf("\n1.Insert 2.Search 3.Delete 4.Display 5.Exit\n");
        scanf("%d", &choice);

        switch (choice) {
        case 1:
            printf("Enter key: ");
            scanf("%d", &key);
            insert(key);
            break;
        case 2:
            printf("Enter key: ");
            scanf("%d", &key);
            search(key);
            break;
        case 3:
            printf("Enter key: ");
            scanf("%d", &key);
            delete(key);
            break;
        case 4:
            display();
            break;
        case 5:
            return 0;
        }
    }
}

b)	Write a C program to implement a hash table using Open Addressing with Quadratic Probing. Perform the following operations. (Assume all keys are positive integers) a. Insert b. Search c. Delete d. Display

#include <stdio.h>
#define SIZE 10

int table[SIZE];

int hash(int key) {
    return key % SIZE;
}

void init() {
    for (int i = 0; i < SIZE; i++)
        table[i] = -1;
}

void insert(int key) {
    int index = hash(key);
    int i = 1;

    while (table[index] != -1) {
        index = (hash(key) + i * i) % SIZE;
        i++;
    }
    table[index] = key;
}

void search(int key) {
    int index = hash(key);
    int i = 1;

    while (table[index] != -1) {
        if (table[index] == key) {
            printf("Search Found\n");
            return;
        }
        index = (hash(key) + i * i) % SIZE;
        i++;
    }
    printf("Search Not Found\n");
}

void delete(int key) {
    int index = hash(key);
    int i = 1;

    while (table[index] != -1) {
        if (table[index] == key) {
            table[index] = -1;
            printf("Key Deleted\n");
            return;
        }
        index = (hash(key) + i * i) % SIZE;
        i++;
    }
    printf("Key Not Found\n");
}

void display() {
    for (int i = 0; i < SIZE; i++)
        printf("%d : %d\n", i, table[i]);
}

int main() {
    int choice, key;
    init();

    while (1) {
        printf("\n1.Insert 2.Search 3.Delete 4.Display 5.Exit\n");
        scanf("%d", &choice);

        switch (choice) {
        case 1:
            printf("Enter key: ");
            scanf("%d", &key);
            insert(key);
            break;
        case 2:
            printf("Enter key: ");
            scanf("%d", &key);
            search(key);
            break;
        case 3:
            printf("Enter key: ");
            scanf("%d", &key);
            delete(key);
            break;
        case 4:
            display();
            break;
        case 5:
            return 0;
        }
    }
}






SET A
⭐ Set A (a) — Hash Functions
(Division, Mid Square, Digit Folding)
Enter number of values: 6
Enter value: 23
Enter value: 43
Enter value: 13
Enter value: 27
Enter value: 88
Enter value: 18

✅ Sample Output
Collision in Division Method at index 3
Collision in Mid Square Method at index 8
Collision in Digit Folding Method at index 9
Note: Output may vary depending on hash collisions.

Set A (b) — Separate Chaining
✅ Sample Input

1.Insert
Enter key: 25

1.Insert
Enter key: 35

1.Insert
Enter key: 15

1.Insert
Enter key: 7

4.Display

✅ Sample Output
0: NULL
1: NULL
2: NULL
3: NULL
4: NULL
5: 15 -> 35 -> 25 -> NULL
6: NULL
7: 7 -> NULL
8: NULL
9: NULL
✅ Search Operation
Input
2.Search
Enter key: 35
Output
Search Found
________________________________________
✅ Delete Operation
Input
3.Delete
Enter key: 35
Output
Key Deleted
________________________________________
✅ Display After Deletion
Output
5: 15 -> 25 -> NULL
7: 7 -> NULL

⭐ Set B (a) — Linear Probing
✅ Sample Input
1.Insert -> 10
1.Insert -> 20
1.Insert -> 30
1.Insert -> 40
4.Display

✅ Sample Output
0 : 10
1 : 20
2 : 30
3 : 40
4 : -1
5 : -1
6 : -1
7 : -1
8 : -1
9 : -1

✅ Search
2.Search
Enter key: 20
Output:
Search Found

________________________________________
✅ Delete
Input
3.Delete
Enter key: 20

Output:
Key Deleted


⭐ Set B (b) — Quadratic Probing
✅ Sample Input
1.Insert -> 11
1.Insert -> 21
1.Insert -> 31
1.Insert -> 41
4.Display

✅ Sample Output
1 : 11
2 : 21
5 : 31
0 : 41

✅ Search
Input
2.Search
Enter key: 31

Output
Search Found

✅ Delete
Input
3.Delete
Enter key: 21


Output
Key Deleted

