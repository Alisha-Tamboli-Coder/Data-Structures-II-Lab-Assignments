Assignment 4 – Graph Application
Set A 
a)	Write a C program for the implementation of Topological sorting. 

#include <stdio.h>

int n;
int adj[10][10];
int visited[10], stack[10], top = -1;

void dfs(int v)
{
    int i;
    visited[v] = 1;

    for (i = 0; i < n; i++)
        if (adj[v][i] == 1 && !visited[i])
            dfs(i);

    stack[++top] = v;
}

int main()
{
    int i, j;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter adjacency matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &adj[i][j]);

    for (i = 0; i < n; i++)
        visited[i] = 0;

    for (i = 0; i < n; i++)
        if (!visited[i])
            dfs(i);

    printf("Topological Order: ");
    for (i = top; i >= 0; i--)
        printf("%d ", stack[i]);

    return 0;
}


b)	Write a C program for the Implementation of Prim’s Minimum spanning tree algorithm. 

#include <stdio.h>
#define INF 999

int main()
{
    int n, i, j;
    int cost[10][10], key[10], mstSet[10], parent[10];
    int min, u;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter adjacency cost matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &cost[i][j]);

    for (i = 0; i < n; i++)
    {
        key[i] = INF;
        mstSet[i] = 0;
    }

    key[0] = 0;
    parent[0] = -1;

    for (i = 0; i < n - 1; i++)
    {
        min = INF;
        for (j = 0; j < n; j++)
            if (!mstSet[j] && key[j] < min)
            {
                min = key[j];
                u = j;
            }

        mstSet[u] = 1;

        for (j = 0; j < n; j++)
            if (cost[u][j] && !mstSet[j] && cost[u][j] < key[j])
            {
                parent[j] = u;
                key[j] = cost[u][j];
            }
    }

    printf("Edge \tWeight\n");
    for (i = 1; i < n; i++)
        printf("%d - %d \t%d\n", parent[i], i, cost[i][parent[i]]);

    return 0;
}


c)Write a C program for the Implementation of Kruskal’s Minimum spanning tree algorithm. 

#include <stdio.h>

int parent[10];

int find(int i)
{
    while (parent[i])
        i = parent[i];
    return i;
}

int uni(int i, int j)
{
    if (i != j)
    {
        parent[j] = i;
        return 1;
    }
    return 0;
}

int main()
{
    int n, i, j, min, a, b, u, v;
    int cost[10][10];
    int ne = 1, mincost = 0;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter adjacency cost matrix:\n");
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++)
        {
            scanf("%d", &cost[i][j]);
            if (cost[i][j] == 0)
                cost[i][j] = 999;
        }

    while (ne < n)
    {
        min = 999;
        for (i = 1; i <= n; i++)
            for (j = 1; j <= n; j++)
                if (cost[i][j] < min)
                {
                    min = cost[i][j];
                    a = u = i;
                    b = v = j;
                }

        u = find(u);
        v = find(v);

        if (uni(u, v))
        {
            printf("Edge %d: (%d - %d) cost:%d\n", ne++, a, b, min);
            mincost += min;
        }
        cost[a][b] = cost[b][a] = 999;
    }

    printf("Minimum cost = %d\n", mincost);
    return 0;
}


Set B 

a) Write a C program for the implementation of Dijkstra’s shortest path algorithm for finding 
shortest path from a given source vertex using adjacency cost matrix. 

#include <stdio.h>
#define INF 999

int main()
{
    int n, i, j, source;
    int cost[10][10], dist[10], visited[10];
    int min, u;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter adjacency cost matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &cost[i][j]);

    printf("Enter source vertex: ");
    scanf("%d", &source);

    for (i = 0; i < n; i++)
    {
        dist[i] = INF;
        visited[i] = 0;
    }

    dist[source] = 0;

    for (i = 0; i < n - 1; i++)
    {
        min = INF;
        for (j = 0; j < n; j++)
            if (!visited[j] && dist[j] < min)
            {
                min = dist[j];
                u = j;
            }

        visited[u] = 1;

        for (j = 0; j < n; j++)
            if (!visited[j] && cost[u][j] && dist[u] + cost[u][j] < dist[j])
                dist[j] = dist[u] + cost[u][j];
    }

    printf("Shortest distances from source %d:\n", source);
    for (i = 0; i < n; i++)
        printf("%d -> %d\n", i, dist[i]);

    return 0;
}


b)Write a C program for the implementation of Floyd Warshall’s algorithm for finding all pairs shortest path using adjacency cost matrix.

#include <stdio.h>
#define INF 999

int main()
{
    int n, i, j, k;
    int dist[10][10];

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter adjacency cost matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &dist[i][j]);

    for (k = 0; k < n; k++)
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];

    printf("All Pairs Shortest Path Matrix:\n");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
            printf("%d ", dist[i][j]);
        printf("\n");
    }

    return 0;
}




Inputs :--
Set A
a)	Topological Sorting
Enter number of vertices: 6
Enter adjacency matrix:
0 1 1 0 0 0
0 0 0 1 1 0
0 0 0 1 0 0
0 0 0 0 0 1
0 0 0 0 0 1
0 0 0 0 0 0

Output :-
Topological Order: 0 2 1 4 3 5
Note: Topological ordering may vary depending on DFS traversal.

b) Prim’s Minimum Spanning Tree
Enter number of vertices: 5
Enter adjacency cost matrix:
0 2 0 6 0
2 0 3 8 5
0 3 0 0 7
6 8 0 0 9
0 5 7 9 0

Output :-
Edge    Weight
0 - 1   2
1 - 2   3
0 - 3   6
1 - 4   5


c) Kruskal’s Minimum Spanning Tree

Enter number of vertices: 4
Enter adjacency cost matrix:
0 10 6 5
10 0 0 15
6 0 0 4
5 15 4 0

Output
Edge 1: (3 - 4) cost:4
Edge 2: (1 - 4) cost:5
Edge 3: (1 - 2) cost:10
Minimum cost = 19




Set B  
a)dijkstra’s Shortest Path Algorithm
Enter number of vertices: 5
Enter adjacency cost matrix:
0 10 0 30 100
0 0 50 0 0
0 0 0 0 10
0 0 20 0 60
0 0 0 0 0
Enter source vertex: 0

Outpot:-
Shortest distances from source 0:
0 -> 0
1 -> 10
2 -> 50
3 -> 30
4 -> 60

Note: Dijkstra’s algorithm works only for graphs with non-negative weights.

________________________________________
b) Floyd–Warshall Algorithm (All Pairs Shortest Path)
Sample Input
Enter number of vertices: 4

Enter adjacency cost matrix:
0 3 999 7
8 0 2 999
5 999 0 1
2 999 999 0
Sample Output
All Pairs Shortest Path Matrix:

0 3 5 6
5 0 2 3
3 6 0 1
2 5 7 0

